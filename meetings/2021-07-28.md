# 2021-07-28 Solid Authorization

https://meet.jit.si/solid-authorization


## Agenda

* Minutes - https://github.com/solid/authorization-panel/pull/240
* UC0 - https://github.com/solid/authorization-panel/pull/244
* UC3 - https://github.com/solid/authorization-panel/pull/241
* ACL on ACL - https://github.com/solid/authorization-panel/issues/189
* Mode range: https://github.com/solid/authorization-panel/issues/187

## Present

* Elf Pavlik
* Sarven Capadisli
* Henry Story
* Matthieu Bosquet


## Minutes

## UC0

Sarven: What happens when you get a 403 on ACR?

Matthieu: I don't think we have a good required credentials discovery mechanism. That's what we need defining.

Sarven: You have `foo` and `foo.acl`. If I get a `404` on `foo.acl`, it tells me that `foo` potentially exists. It emphasises on the authorise. If you know that `foo` exists but don't have access to it, getting a `403` (or `404`) is fine.

Elf: Go to `foo`, get a header to the `acl`, how do you know?

Sarven: Whether you know or not that `foo.acl` exists. It's fine, but if you don't know it exists, what should happen?

Elf: Without knowing that `foo` exists, you don't get to know that the ACL exists.

Sarven: If you don't know that `foo` exists, you should get a `403`.

Elf: How do you get a response you don't get a response.

Sarven: Just guessing URLs. If I look at the resource directly, I can see that file exists.
But let's say I don't have read access to the container, but I'm guessing the filename `work-on-the-weekend.txt` and then I'm getting to the `acl`.
If you don't know the existence of a resource, you get a `403`.

Henry: How would the server know what you know?

Sarven: Because you're authorized (or not).

Henry: I think we need to go at it from an unauthenticated perspective.
The first thing we have to cover is how to build apps that work across pods.
Everyone is using social networks because they are easy to use, have access control and help connect people 
But, for the moment, these are all done on centralized servers.

In a 2012 paper [Tracing the Man in the Middle in Monoidal Categoires](https://link.springer.com/chapter/10.1007/978-3-642-32784-1_11) Dusko Pavlovic wrote:

> In the MM-attacks on authentication protocols, the intruder inserts himself1 between the honest parties, and impersonates them to each other. MM is the strategy used by the chess amateur who plays against two grand masters in parallel, and either wins against one of them, or ties with both. MM is also used by the spammers, whose automated agents solve the automated Turing test by passing it to the human visitors of a free porn site, set up for that purpose [20]. MM is, in a sense, one of the dominant business model on the web, where the portals, search engines and social networks on one hand insert themselves between the producers and the consumers of information, and retrieve freely gathered information for free, but on the other hand use their position in the middle to insert themselves between the producers and the consumers of goods, and supply advertising for a fee. In security protocols, MM is, of course, an interesting attack pattern.

So if we can move people to work with decentralised apps, then we are solving a real problem.

We can later also solve problems of how much information we may possibly be leaking, though in that case we should be looking at deploying Solid on protocols like Tor.

For the moment, the problem is how an app following links knows how to authenticate?
Currently, with WAC, it can not find out.
Because right now, if you follow a link from somewhere on the web to a Pod, then the only agent that can follow the ACL link is the Controller.
If I am a friend of yours and follow links and want to read something, I have no idea what identity to use in order to access resources.
So if the only server able to read my resources is myself
then we do not have a decentralized network: we have a 1990s PC.

There have been many experiments in giving the user back control of their data that make this mistake: they put a user at the center, but then fail to make a useable protocol that makes exchanging data easy. For example, the original [mes infos](http://mesinfos.fing.org) project I mentioned recently, for personal cloud computing in france had this type of architecture. The user could save his own data, but the protocol for exchanging this with anyone else was some JSON RPC style.

1980ies PCs is not the decentralization we are aiming at.
We do not want to make the same mistake. We want to be able to share data, so that we can build a network effect. 
(True: the current WAC does allow the sharing of data, but only if it is public, so we are somewhat beyond 1980s).
The question is, how do I, coming across a link to a protected resource, learn what the access control rules are?
There is a simple answer, which would be making the ACLs more readable than the resources.

Sarven: We can introduce a new access mode like ControlRead. Or using problem details, e.g., on 403, payload indicating required credentials (over 18), we can describe the structure/semantics as well on the Protocol level.

Henry: Yes, ControlRead or ACLs on ACLs would do.
We need the access control rules to be readable by the client.

Elf: I don't think that's correct. I strongly disagree with the statement you make that it is holding in all cases.

Henry: OK, not all ACLs MUST be readable publically. But it should be possible to set the visibility of ACLs. 

Elf: All browsers I know of have a notion of profile that limits the identity I use to log into a site to one identity. None of them have a feature that allows you to switch between identities whilst using a profile. 

Henry: There is a simple explanation for this: all (most) IDs on the web are currently local to a server. Certainly: all passwords are like that; and decentralized IDs such as OpenID,  authenticate you to a whole server, so there is a simple 1 ID per server mapping. 
The situation is very different for decentralised applications (hyper-Apps); such clients follow links from data on one pod to another regularly. And it is quite likely that people around the web know you under different identities, as belonging to different groups. So one resource may be giving you access with your personal WebID, the other with your business WebID and a third with some key that you have used elsewhere. The owners of these resources may be ignorant of the relation between these identifiers. 

Your IDs are tied to a domain, and the browser vendors are not addressing the use case we are putting forward.

Elf: What we're discussing in the interop panel is that you would notify agents that they have access to x. So applications have a discovery mechanism, and the agent would know which identity is tied to access to specific resources.

Matthieu: Is it a centralised, cross-identity notification system?

Elf: At the moment, we don't define how to keep track of all your identities, but each identity would have an associated inbox where they receive the notification about what they have access to.
The authorization agent of Alice would have access to specific grants, and not all applications would have access to all grants.

Henry: (post conf-call) An inbox that would allow you to receive notifications about private group membership is [something that ACLS on ACLs can make use of](https://github.com/solid/authorization-panel/issues/189#issuecomment-797638239).

Matthieu: I do not understand why the default from a security perspective is not 404.

Sarven: First of all, `403` is defined and has meaning. If you can read the container and see that `foo` is linked to it, you already know that the resource exists. If you get that resource, you can get a `403`, but since you know the resource exists `404` doesn't make sense. But the RFC also says you can use `404` to hide information.
You're describing the purpose of hiding information.
But you're capable of finding out on the request that a resource exists. So you're not hiding.

Henry: Sorry the 404 issue is really boring me.  We have been discussing it for 20 minutes or so, and it was not on the topics up for discussion. There is no immediate issue that is relevant to our work here.

Sarven: The first thing I said is whether the evaluation should take this into account.

Henry: If you put up this question, we can put up a Use Case and have a user story where this is an issue and show how the different systems work. But out of the blue like that, we don't have anything that can be constructively discussed. 

 It seems overly paranoid to me as a UC. That is to discuss giving out one bit of information - whether some resource exists or not - when we don't have a system that is working in allowing us to cooperate across the web, is emphasizing the wrong thing. As I mentioned above, currently most people are loosing terrabytes of information to large companies that have set up men MiM services. 
 
If we are going to be serious about security to the level of worrying about bits of information, then we need to look at the [Tor Use Case](https://solid.github.io/authorization-panel/authorization-ucr/#uc-limituri). There we consider even the danger of losing bits of information in path hierarchies leaked through slash semantics. So to get to this level of seriousness we are  going to have to put things behind Tor.
But that requires a lot of other things: for example better integration of LDP into Solid, and the creation of iContainers.

Sarven: Just know that it comes up in the community group as a discussion we're trying to figure out. The more input we have, the better.
Not only is it a security threat, but it's also valuable to answer.

Henry: Yes, but we need priorities: building something that allows people  to get off  centralised systems is the first priority. We can not start with security perfection.
If I were to pay people to think about decentralised networks, I wouldn't start with things that are almost unimportant for now, at this stage; I think it comes later. There are leaks and security issues everywhere.
Are we writing software that is so well written that we're looking at marginal security use cases? Probably not yet.
For me it is really important to have the Tor example (Solid behind Tor). That will be key in winning the security community over. And hopefully they can then help us fix things. But I do not think yo will convince any of them with a discussion of 404 vs 403.


### UC3

Elf: I think we should focus on inheritance.

Matthieu: Let's merge as is, and dedicate a whole conversation and proper Use Cases to required credentials discovery, since it is a strong thread, and you, too, Henry, have pointed that the question has not been answered previously in similar experiments.


### ACL Control

This came from the discussion of [ACLs on ACLs](https://github.com/solid/authorization-panel/issues/189).


Henry: What is weird about the Control mode, in a way is that it is not about the `accessTo` resource, as for Read and Write, but about the subject resoruce.  Instead of having control, you could get read and write over an ACL. That makes me think you could deprecate Control where the Read and Write. All we need is Read and Write:

```Turtle
<#aclOnAcl> a :Authorization;
   :mode :Read, :Write;
   :accessTo <> ;
   :agent </#owner> .
```

Sarven: I don't see even right now how the WAC spec prevents you from having an ACL resource over an ACL resource. It could indeed advertise its own ACL resource. Indeed, I think we could have an implementation that is spec conforming that uses ACLs on ACLs.

Matthieu: See also https://github.com/solid/specification/issues/14#issuecomment-683480525

Henry: The way would be to have a self referencing header, if the ACL resource is its own ACL (that could be the default). 

We were also considereing how to allow users to tune that? You could point the ACL to other documents that have their own rights. But how does one edit headers? (We don't need this to be a priority thing to consider but it would be good to have potential answers to these questions)

Sarven: There is a draft solution: link and unlink headers (<https://tools.ietf.org/id/draft-snell-link-method-01.html>); see also <https://gitter.im/solid/specification?at=5ec2c02e7da13f3a0ac0141c>, <https://github.com/solid/web-access-control-spec/issues/91#issuecomment-562169309>. That could have been used to change the interaction models in LDP. If we picked that spec up, we could do it.

Henry: 10 Years ago, when there was only a `Link: <?meta> rel="meta"> header, I seem to think it was possible to just edit the link headers there.
It gets complicated but it would be good to explore.
It would allow different levels of protections for ACLS. It would be interesting to know whether it is possible.


## Actions

* Henry to look at UC0 and merge.
* Matthieu to look at UC3 and add `acp:access`
* Matthieu to finish answering the range of `acl:mode`
* Matthieu to comment on the HTTP `404` vs `403` issue
